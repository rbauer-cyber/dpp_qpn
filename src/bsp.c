/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: dpp.qm
* File:  ${.::bsp.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpn.h"      // QP-nano framework
#include "Arduino.h"  // Main include file for the Arduino SDK
#include "philo.h"
#include "table.h"
#include "bsp.h"
#include "console.h"

//============================================================================
// Board Support Package

//uint16_t s_updateCount = 0;
//const uint16_t kUpdateCount = 10;

void BSP_displayPhilStat(uint8_t n, uint8_t dppSignal) {
    Philo* AO_Ptr = &AO_Philo[n];
    uint8_t ledPin = AO_Ptr->m_ledPin;
    uint32_t timeNow = millis();
    uint32_t elapsedTime;

    DECLARE_AND_INIT(char_t*, stat, "unknown");

    if (dppSignal == EAT_SIG) {
        STRING_PTR_ASSIGN(stat, "eating");

        if ( AO_Ptr->m_pwmEnabled )
            analogWrite(ledPin, 255);
        else
            digitalWrite(ledPin, HIGH);
    }
    else if (dppSignal == HUNGRY_SIG) {
        STRING_PTR_ASSIGN(stat, "hungry");
    }
    else if (dppSignal == THINKING_SIG) {
        STRING_PTR_ASSIGN(stat, "thinking");

        if ( AO_Ptr->m_pwmEnabled )
            analogWrite(ledPin, 5);
        else
            digitalWrite(ledPin, LOW);
    }
    else {
        STRING_PTR_ASSIGN(stat, "unknown");
    }

    elapsedTime = timeNow - AO_Ptr->m_elapsedTime;
    AO_Ptr->m_elapsedTime = timeNow;
    DEBUG_ARGS("Table: philosopher %d %s %lu", n, stat, elapsedTime);
}
//............................................................................
void BSP_displayPaused(uint8_t paused) {
    DECLARE_AND_INIT(char_t*, pausedMsg, "Paused OFF");
    if ( paused ) STRING_PTR_ASSIGN(pausedMsg, "Paused ON");
    DEBUG_ARGS("Table: %s", pausedMsg);
}

//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    SMCR = (0 << SM0) | (1 << SE); // idle mode, adjust to your project
    QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
/*****************************************************************//**
* ISR TIMER2 COMPA
*********************************************************************/
//static uint8_t s_timerCount = 0;

#if 0
ISR(TIMER2_COMPA_vect) {
    if ( s_timerCount++ > TIMER_SCALAR ) {
        s_timerCount = 0;
        QF_tickXISR(0); // process time events for tick rate 0
    }
};
#endif

// interrupts
ISR(TIMER2_COMPA_vect) {
    QF_tickXISR(0); // process time events for tick rate 0
#if 1
    if (consoleInputReady() > 0) {
        switch ( consoleReadByte() ) { // read the incoming byte
            case 'p':
            case 'P':
                QACTIVE_POST_ISR(&AO_Table, PAUSE_SIG, 0U);
                break;
            case 's':
            case 'S':
                QACTIVE_POST_ISR(&AO_Table, SERVE_SIG, 0U);
                break;
        }
    }
#endif
}


/*****************************************************************//**
* BSP_initTick()
*********************************************************************/
void BSP_initTick(void) {
    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U << WGM21) | (0U << WGM20);
    TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
    ASSR  &= ~(1U << AS2);
    TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency, 1Khz
    OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
};

void BSP_initSetup(void)
{
    // initialize the hardware used in this sketch...
    uint8_t ledPin = 8;

    for (uint8_t i = 0; i < ARRAY_SIZE(AO_Philo); i++ )
    {
        Philo* AO_Ptr = &AO_Philo[i];
        uint8_t theLedPin = ledPin+i;
        AO_Ptr->m_ledPin = theLedPin;
        //AO_Ptr->m_pwmEnabled = ( theLedPin >= 9 && theLedPin <= 11 ) ? 1 : 0;
        //PWM mode not working reliably so disable.
        AO_Ptr->m_pwmEnabled = 0;
        AO_Ptr->m_elapsedTime = millis();
        AO_Ptr->m_id = i;

        pinMode(ledPin+i, OUTPUT); // set the LED pin to output

        if (AO_Ptr->m_pwmEnabled)
            analogWrite(theLedPin, 0);
        else
            digitalWrite(theLedPin, LOW);
    }
}

