/*$file${.::main.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: dpp.qm
* File:  ${.::main.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::main.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpn.h"      // QP-nano framework
#include "philo.h"
#include "table.h"
#include "bsp.h"
#include "console.h"

//Q_DEFINE_THIS_MODULE("dpp")

//============================================================================
//...

// define all AO instances and event queue buffers for them...
static QEvt l_philoQueue[N_PHILO][N_PHILO];
static QEvt l_tableQueue[2];
//...

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,            (QEvt *)0,        0U                      },
    { (QActive *)&AO_Philo[0], l_philoQueue[0],  Q_DIM(l_philoQueue[0])  },
    { (QActive *)&AO_Philo[1], l_philoQueue[1],  Q_DIM(l_philoQueue[1])  },
    { (QActive *)&AO_Philo[2], l_philoQueue[2],  Q_DIM(l_philoQueue[2])  },
    { (QActive *)&AO_Philo[3], l_philoQueue[3],  Q_DIM(l_philoQueue[3])  },
    { (QActive *)&AO_Philo[4], l_philoQueue[4],  Q_DIM(l_philoQueue[4])  },
    { (QActive *)&AO_Table,    l_tableQueue,     Q_DIM(l_tableQueue)     }
};

//............................................................................
//............................................................................
void setup() {
    // initialize the QF-nano framework
    consoleInit();
    QF_init(Q_DIM(QF_active));

    // initialize all AOs...
    QActive_ctor(&AO_Philo[0].super, Q_STATE_CAST(&Philo_initial));
    QActive_ctor(&AO_Philo[1].super, Q_STATE_CAST(&Philo_initial));
    QActive_ctor(&AO_Philo[2].super, Q_STATE_CAST(&Philo_initial));
    QActive_ctor(&AO_Philo[3].super, Q_STATE_CAST(&Philo_initial));
    QActive_ctor(&AO_Philo[4].super, Q_STATE_CAST(&Philo_initial));
    QActive_ctor(&AO_Table.super,    Q_STATE_CAST(&Table_initial));

    BSP_initSetup();

    DEBUG_ARGS("QP-nano: %s ", QP_VERSION_STR);
}

//............................................................................
void loop() {
    QF_run(); // run the QP-nano application
}

//============================================================================
//============================================================================
// QF callbacks...
void QF_onStartup(void) {
    BSP_initTick();
}
//............................................................................
Q_NORETURN Q_onAssert(char const Q_ROM * const module, int location) {
    // implement the error-handling policy for your application!!!
    //Serial.print(F("ASSERTION:"));
    //Serial.print(module);
    //Serial.print(location, DEC);
    DEBUG_ARGS("ASSERTION %s %d", module, location);
    for (uint32_t volatile i = 100000U; i > 0U; --i) {
    }
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET();  // reset the CPU
    for (;;) {
    }
}


//...

